<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
  </head>
  <body>
    <script>
      /**
       *왜 객체지향 프로그래밍을 해야할까!?
       * 1. 깔끔하고 이해하기 쉬운 코드를 짤 수 있다
       * 2. 확장하기 쉬운 코드를 짤 수 있다
       * 3.유지보수 하기 쉬운 코드를 짤 수 있다.
       * 4. 메모리를 절약하는 코드를 짤 수 있다.
       * 객체와 장소를 모아둔 곳
       * 로봇의 머리 , 팔 ,다리 등 컴포넌트를 나눠서 하나로 합쳐 개발하는 프로그래밍 방식
       *
       */
      // 절차지향식 프로그래밍

      //   let name = "재현",
      //     weapon = "검";
      //   function attack() {
      //     return `${name}이 ${weapon}으로 공격합니다!`;
      //   }
      //   function changeWeapon() {
      //     weapon = "창";
      //     return `무기가 ${weapon}으로 교체되었습니다.`;
      //   }

      // 객체지향식 프로그래밍

      //   const knight = {
      //     name: "재현",
      //     weapon: "검",
      //     attack() {
      //       return `${knight.name}이 ${this.weapon}으로 공격합니다`;
      //     },
      //     changeWeapon(newWeapon) {
      //       this.weapon = newWeapon;
      //       return `무기가 ${this.weapon}으로 교체되었습니다.`;
      //     },
      //   };
      //   encapsulation ==> 캡슐화 한다.
      // 데이터와 데이터를 조작하는 메서드를 하나의 단위로 묶는 것
      //단점 :필요할때마다 새로 생성해야 하고 같은 함수를 반복한다.

      // 생성자 함수로 생성하기
      //   function Knight(name, weapon) {
      //     this.name = name;
      //     this.weapon = weapon;
      //   }
      //   Knight.prototype.attack = function () {
      //     return `${this.name}이 ${this.weapon}으로 공격합니다.`;
      //   };
      //   Knight.prototype.changeWeapon = function (newWeapon) {
      //     this.weapon = newWeapon;
      //     return `무기가 ${this.weapon}으로 교체되었습니다`;
      //   };
      // 단점 : 캡슐화가 안된다

      class BaseCharactor {
        constructor(name, weapon) {
          this.name = name;
          this.weapon = weapon;
        }
        attack() {
          return `${this.name}이 ${this.weapon}으로 공격합니다! `;
        }
        changeWeapon(newWeapon) {
          this.weapon = newWeapon;
          return `무기가 ${this.weapon}으로 교체되었습니다.`;
        }
      }
      //   const knight = new Knight("재웅", "묠니르");

      class Skeleton extends BaseCharactor {
        //새로운 type이 들어와서 constructor를 썼다
        // 새로운 타입이 없다면 constructor를 생략가능! 메서드는 바로 상속이 된다.
        // constructor(name, weapon, unitType) {
        //   super(name, weapon);
        //   this.unitType = unitType;
        // }
      }
      const skeleton = new Skeleton("해골병사", "방패", "악마");
    </script>
  </body>
</html>
